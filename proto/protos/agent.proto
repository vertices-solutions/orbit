syntax = "proto3";
package agent.v1;

// A single prompt displayed during keyboard-interactive auth (e.g. "Duo code:").
message Prompt {
  string text = 1;
  bool echo = 2; // Whether the server allows echoing the user's input
}

// MFA prompt bundle (a single "round" of keyboard-interactive).
message MfaPrompt {
  string name = 1; // e.g. "Duo Security"
  string instructions = 2; // Free text instructions
  repeated Prompt prompts = 3;
}

// Client's answers to a single MFA prompt round.
// The number of responses must match the number of `prompts`.
message MfaAnswer {
  repeated string responses = 1;
}

// Server->client stream items while running a command.
message StreamEvent {
  oneof event {
    bytes stdout = 1; // Chunk from STDOUT
    bytes stderr = 2; // Chunk from STDERR
    int32 exit_code = 3; // Exit code (emitted once when known)
    MfaPrompt mfa = 4; // MFA prompt round
    string error = 5; // Fatal error (connection/auth/exec)
    AddClusterScratchOptions add_cluster_scratch_options = 6; // AddCluster scratch candidates
    AddClusterScratchValidation add_cluster_scratch_validation = 7; // AddCluster scratch validation result
  }
}

message SubmitStatus {
  enum Phase {
    PHASE_UNSPECIFIED = 0;
    RESOLVED = 1;
    TRANSFER_START = 2;
    TRANSFER_DONE = 3;
  }
  string name = 1;
  string remote_path = 2;
  Phase phase = 3;
}

message SubmitResult {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    SUBMITTED = 1;
    FAILED = 2;
  }
  Status status = 1;
  optional int64 job_id = 2;
  string detail = 3;
}

// Server->client stream items while submitting a job.
message SubmitStreamEvent {
  oneof event {
    bytes stdout = 1; // Chunk from STDOUT
    bytes stderr = 2; // Chunk from STDERR
    int32 exit_code = 3; // Exit code (emitted once when known)
    MfaPrompt mfa = 4; // MFA prompt round
    string error = 5; // Fatal error (connection/auth/exec)
    SubmitStatus submit_status = 6; // Submit progress updates
    SubmitResult submit_result = 7; // Submit final status
  }
}

message LsRequestInit {
  string name = 1; // cluster name (optional if job_id is set)
  optional string path = 2; // path to list (absolute or relative to base path)
  optional int64 job_id = 3; // job id to list from (uses job's cluster)
}

// Client -> Server
message LsRequest {
  oneof msg {
    LsRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message RetrieveJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  string path = 3; // remote path (absolute or relative to run folder)
  optional string local_path = 4; // local destination base path
  bool overwrite = 5; // overwrite existing local files
  bool force = 6; // allow retrieving before a job is complete
}

message RetrieveJobRequest {
  oneof msg {
    RetrieveJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message JobLogsRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  bool stderr = 2; // fetch stderr log instead of stdout
}

message JobLogsRequest {
  oneof msg {
    JobLogsRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message CancelJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
}

message CancelJobRequest {
  oneof msg {
    CancelJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message CleanupJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  bool force = 2; // cancel running job before cleanup
  bool full = 3; // delete job record after cleanup
}

message CleanupJobRequest {
  oneof msg {
    CleanupJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message SubmitJobRequestInit {
  string local_path = 1; // local project path
  optional string remote_path = 2; // path to where to locate the remote project
  string name = 3; // cluster name - should be something easy to remember
  string sbatchscript = 4;
  repeated SubmitPathFilterRule filters = 5; // ordered include/exclude rules, rsync-style
  bool new_directory = 6; // ignore prior remote dir for this local path
  bool force = 7; // allow reuse of a running remote directory
  optional string project_name = 8; // project identifier from Orbitfile
  optional string default_retrieve_path = 9; // default retrieve path from Orbitfile
  optional string template_values_json = 10; // template values JSON map from Orbitfile
}

message SubmitProjectRequestInit {
  string project_name = 1; // registered project name
  string project_tag = 2; // project version tag (name:tag submit)
  string name = 3; // cluster name - should be something easy to remember
  string sbatchscript = 4;
  repeated SubmitPathFilterRule filters = 5; // ordered include/exclude rules, rsync-style
  bool new_directory = 6; // ignore prior remote dir for this local path
  bool force = 7; // allow reuse of a running remote directory
  optional string remote_path = 8; // path to where to locate the remote project
  optional string default_retrieve_path = 9; // default retrieve path from Orbitfile
  optional string template_values_json = 10; // template values JSON map from Orbitfile
}

enum SubmitPathFilterAction {
  SUBMIT_PATH_FILTER_ACTION_UNSPECIFIED = 0;
  INCLUDE = 1;
  EXCLUDE = 2;
}

message SubmitPathFilterRule {
  SubmitPathFilterAction action = 1;
  string pattern = 2;
}

message AddClusterInit {
  string name = 1; // memorable cluster name
  string username = 2; // path to where to locate the remote project
  oneof host {
    string hostname = 3; // hostname or IP address
    string ipaddr = 4;
  }
  optional string identity_path = 5;
  uint32 port = 6;
  optional string default_base_path = 7;
  optional string default_scratch_directory = 8;
  bool interactive_scratch_selection = 9;
}

message AddClusterScratchOptions {
  repeated string directories = 1;
}

message AddClusterScratchSelection {
  oneof selection {
    string directory = 1;
    bool none = 2;
  }
}

message AddClusterScratchValidation {
  bool accepted = 1;
  optional string directory = 2;
  optional string error = 3;
}

message ResolveHomeDirRequestInit {
  string username = 1;
  oneof host {
    string hostname = 2;
    string ipaddr = 3;
  }
  optional string identity_path = 4;
  uint32 port = 5;
  optional string name = 6;
}

message ResolveHomeDirRequest {
  oneof msg {
    ResolveHomeDirRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}
message ListClustersRequest {
  string filter = 1;
  optional bool check_reachability = 2;
}

message ListClustersUnitResponse {
  string username = 1;
  optional string identity_path = 2;
  int32 port = 3;
  oneof host {
    string hostname = 4;
    string ipaddr = 5;
  }
  bool connected = 6;
  string name = 7;
  bool accounting_available = 8;
  optional string default_base_path = 9;
  bool reachable = 10;
}

message ListJobsRequest {
  optional string name = 1;
  optional string project_name = 2;
}

message ListClustersResponse {
  repeated ListClustersUnitResponse clusters = 1;
}

message ListPartitionsRequest {
  string name = 1; // Accepts cluster name as input
}

message ListPartitionsUnitResponse {
  string name = 1; // Partition name
}

message ListPartitionsResponse {
  repeated ListPartitionsUnitResponse partitions = 1; // List of partition names
}

message ListAccountsRequest {
  string name = 1; // Accepts cluster name as input
}

message ListAccountsUnitResponse {
  string name = 1; // Account name
}

message ListAccountsResponse {
  repeated ListAccountsUnitResponse accounts = 1; // List of account names
}

message DeleteClusterRequest {
  string name = 1;
}

message DeleteClusterResponse {
  bool deleted = 1;
}

message SetClusterInit {
  string name = 1;
  optional string host = 2;
  optional string username = 3;
  optional uint32 port = 4;
  optional string identity_path = 5;
  optional string default_base_path = 6;
}

message SetClusterRequest {
  oneof msg {
    SetClusterInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message ListJobsUnitResponse {
  string name = 1;
  int64 job_id = 2;
  optional int64 scheduler_id = 3;
  string created_at = 4;
  optional string finished_at = 5;
  bool is_completed = 6;
  optional string terminal_state = 7; // Scheduler terminal state when known (COMPLETED, FAILED)
  string local_path = 8; // Local directory used for submission
  string remote_path = 9; // Remote directory used for submission
  optional string scheduler_state = 10; // Scheduler state when known (PENDING, RUNNING)
  optional string project_name = 11; // project identifier from Orbitfile at submit time
  optional string default_retrieve_path = 12; // default retrieve path stored at submit time
}

message ListJobsResponse {
  repeated ListJobsUnitResponse jobs = 1;
}

message ProjectRecord {
  string name = 1;
  string path = 2;
  string created_at = 3;
  string updated_at = 4;
  optional string version_tag = 5;
  optional string tarball_hash = 6;
  optional string tool_version = 7;
  optional string template_config_json = 8;
  reserved 9;
  optional string submit_sbatch_script = 10;
  repeated string sbatch_scripts = 11;
  optional string default_retrieve_path = 12;
  repeated string sync_include = 13;
  repeated string sync_exclude = 14;
}

message BuildProjectRequest {
  string path = 1; // project root to package
  bool package_git = 2; // include .git in tarball
  reserved 3;
}

message BuildProjectResponse {
  ProjectRecord project = 1;
}

message UpsertProjectRequest {
  string name = 1;
  string path = 2;
}

message UpsertProjectResponse {
  ProjectRecord project = 1;
}

message GetProjectRequest {
  string name = 1;
}

message GetProjectResponse {
  ProjectRecord project = 1;
}

message ListProjectsRequest {}

message ListProjectsResponse {
  repeated ProjectRecord projects = 1;
}

message DeleteProjectRequest {
  string name = 1;
}

message DeleteProjectResponse {
  bool deleted = 1;
}

// Client -> Server
message SubmitJobRequest {
  oneof msg {
    SubmitJobRequestInit init = 1; // Initial file path submission
    MfaAnswer mfa = 2;
  }
}

// Client -> Server
message SubmitProjectRequest {
  oneof msg {
    SubmitProjectRequestInit init = 1; // Initial project submission
    MfaAnswer mfa = 2;
  }
}
message AddClusterRequest {
  oneof msg {
    AddClusterInit init = 1;
    MfaAnswer mfa = 2;
    AddClusterScratchSelection scratch_selection = 3;
  }
}

message PingRequest {
  string message = 1;
}

message PingReply {
  string message = 1;
}

// One bidirectional streaming method keeps MFA + output on a single pipe.
service Agent {
  rpc Ping(PingRequest) returns (PingReply);
  rpc Ls(stream LsRequest) returns (stream StreamEvent);
  rpc RetrieveJob(stream RetrieveJobRequest) returns (stream StreamEvent);
  rpc JobLogs(stream JobLogsRequest) returns (stream StreamEvent);
  rpc CancelJob(stream CancelJobRequest) returns (stream StreamEvent);
  rpc CleanupJob(stream CleanupJobRequest) returns (stream StreamEvent);
  rpc SubmitJob(stream SubmitJobRequest) returns (stream SubmitStreamEvent);
  rpc SubmitProject(stream SubmitProjectRequest) returns (stream SubmitStreamEvent);
  rpc AddCluster(stream AddClusterRequest) returns (stream StreamEvent);
  rpc ResolveHomeDir(stream ResolveHomeDirRequest) returns (stream StreamEvent);
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse);
  rpc ListPartitions(ListPartitionsRequest) returns (ListPartitionsResponse); // Helper endpoint for listing partitions
  rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse); // Helper endpoint for listing accounts
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse);
  rpc SetCluster(stream SetClusterRequest) returns (stream StreamEvent);
  rpc ListJobs(ListJobsRequest) returns (ListJobsResponse);
  rpc UpsertProject(UpsertProjectRequest) returns (UpsertProjectResponse);
  rpc GetProject(GetProjectRequest) returns (GetProjectResponse);
  rpc ListProjects(ListProjectsRequest) returns (ListProjectsResponse);
  rpc DeleteProject(DeleteProjectRequest) returns (DeleteProjectResponse);
  rpc BuildProject(BuildProjectRequest) returns (BuildProjectResponse);
}
