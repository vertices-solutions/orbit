syntax = "proto3";
package agent.v1;

// A single prompt displayed during keyboard-interactive auth (e.g. "Duo code:").
message Prompt {
  string text = 1;
  bool echo = 2; // Whether the server allows echoing the user's input
}

// MFA prompt bundle (a single "round" of keyboard-interactive).
message MfaPrompt {
  string name = 1; // e.g. "Duo Security"
  string instructions = 2; // Free text instructions
  repeated Prompt prompts = 3;
}

// Client's answers to a single MFA prompt round.
// The number of responses must match the number of `prompts`.
message MfaAnswer {
  repeated string responses = 1;
}

// Server->client stream items while running a command.
message StreamEvent {
  oneof event {
    bytes stdout = 1; // Chunk from STDOUT
    bytes stderr = 2; // Chunk from STDERR
    int32 exit_code = 3; // Exit code (emitted once when known)
    MfaPrompt mfa = 4; // MFA prompt round
    string error = 5; // Fatal error (connection/auth/exec)
    AddClusterScratchOptions add_cluster_scratch_options = 6; // AddCluster scratch candidates
    AddClusterScratchValidation add_cluster_scratch_validation = 7; // AddCluster scratch validation result
    AddClusterBasePathPrompt add_cluster_base_path_prompt = 8; // AddCluster default base path prompt
    AddClusterBasePathValidation add_cluster_base_path_validation = 9; // AddCluster default base path validation result
    AddClusterDefaultPrompt add_cluster_default_prompt = 10; // AddCluster default cluster prompt
  }
}

message RunStatus {
  enum Phase {
    PHASE_UNSPECIFIED = 0;
    RESOLVED = 1;
    TRANSFER_START = 2;
    TRANSFER_DONE = 3;
  }
  string name = 1;
  string remote_path = 2;
  Phase phase = 3;
}

message RunResult {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    SUBMITTED = 1;
    FAILED = 2;
  }
  Status status = 1;
  optional int64 job_id = 2;
  string detail = 3;
}

// Server->client stream items while running a job.
message RunStreamEvent {
  oneof event {
    bytes stdout = 1; // Chunk from STDOUT
    bytes stderr = 2; // Chunk from STDERR
    int32 exit_code = 3; // Exit code (emitted once when known)
    MfaPrompt mfa = 4; // MFA prompt round
    string error = 5; // Fatal error (connection/auth/exec)
    RunStatus run_status = 6; // Run progress updates
    RunResult run_result = 7; // Run final status
  }
}

message LsRequestInit {
  string name = 1; // cluster name (optional if job_id is set)
  optional string path = 2; // path to list (absolute or relative to base path)
  optional int64 job_id = 3; // job id to list from (uses job's cluster)
}

// Client -> Server
message LsRequest {
  oneof msg {
    LsRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message RetrieveJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  string path = 3; // remote path (absolute or relative to run folder)
  optional string local_path = 4; // local destination base path
  bool overwrite = 5; // overwrite existing local files
  bool force = 6; // allow retrieving before a job is complete
}

message RetrieveJobRequest {
  oneof msg {
    RetrieveJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message JobLogsRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  bool stderr = 2; // fetch stderr log instead of stdout
}

message JobLogsRequest {
  oneof msg {
    JobLogsRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message CancelJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
}

message CancelJobRequest {
  oneof msg {
    CancelJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message CleanupJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  bool force = 2; // cancel running job before cleanup
  bool full = 3; // delete job record after cleanup
}

message CleanupJobRequest {
  oneof msg {
    CleanupJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message RunJobRequestInit {
  string local_path = 1; // local run path
  optional string remote_path = 2; // path to where to locate the remote run
  string name = 3; // cluster name - should be something easy to remember
  string sbatchscript = 4;
  repeated RunPathFilterRule filters = 5; // ordered include/exclude rules, rsync-style
  bool new_directory = 6; // ignore prior remote dir for this local path
  reserved 7; // previously: force
  optional string blueprint_name = 8; // blueprint identifier from Orbitfile
  optional string default_retrieve_path = 9; // default retrieve path from Orbitfile
  optional string template_values_json = 10; // template values JSON map from Orbitfile
}

message RunBlueprintRequestInit {
  string blueprint_name = 1; // registered blueprint name
  string blueprint_tag = 2; // blueprint version tag (name:tag run)
  string name = 3; // cluster name - should be something easy to remember
  string sbatchscript = 4;
  repeated RunPathFilterRule filters = 5; // ordered include/exclude rules, rsync-style
  bool new_directory = 6; // ignore prior remote dir for this local path
  reserved 7; // previously: force
  optional string remote_path = 8; // path to where to locate the remote blueprint
  optional string default_retrieve_path = 9; // default retrieve path from Orbitfile
  optional string template_values_json = 10; // template values JSON map from Orbitfile
}

enum RunPathFilterAction {
  RUN_PATH_FILTER_ACTION_UNSPECIFIED = 0;
  INCLUDE = 1;
  EXCLUDE = 2;
}

message RunPathFilterRule {
  RunPathFilterAction action = 1;
  string pattern = 2;
}

message AddClusterInit {
  string name = 1; // memorable cluster name
  string username = 2; // SSH username
  oneof host {
    string hostname = 3; // hostname or IP address
    string ipaddr = 4;
  }
  optional string identity_path = 5;
  uint32 port = 6;
  optional string default_base_path = 7;
  optional string default_scratch_directory = 8;
  bool interactive_scratch_selection = 9;
}

message AddClusterScratchOptions {
  repeated string directories = 1;
}

message AddClusterScratchSelection {
  oneof selection {
    string directory = 1;
    bool none = 2;
  }
}

message AddClusterScratchValidation {
  bool accepted = 1;
  optional string directory = 2;
  optional string error = 3;
}

message AddClusterBasePathPrompt {
  string suggested_path = 1;
}

message AddClusterBasePathSelection {
  string path = 1;
}

message AddClusterBasePathValidation {
  bool accepted = 1;
  optional string path = 2;
  optional string error = 3;
}

message AddClusterDefaultPrompt {
  optional string current_default_name = 1; // optional context for client-facing prompt text
}

message AddClusterDefaultSelection {
  bool is_default = 1;
}

message ResolveHomeDirRequestInit {
  string username = 1;
  oneof host {
    string hostname = 2;
    string ipaddr = 3;
  }
  optional string identity_path = 4;
  uint32 port = 5;
  optional string name = 6;
}

message ResolveHomeDirRequest {
  oneof msg {
    ResolveHomeDirRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}
message ListClustersRequest {
  string filter = 1;
  optional bool check_reachability = 2;
}

message ListClustersUnitResponse {
  string username = 1;
  optional string identity_path = 2;
  int32 port = 3;
  oneof host {
    string hostname = 4;
    string ipaddr = 5;
  }
  bool connected = 6;
  string name = 7;
  bool accounting_available = 8;
  optional string default_base_path = 9;
  bool reachable = 10;
  bool is_default = 11;
  optional string default_scratch_directory = 12;
}

message ListJobsRequest {
  optional string name = 1;
  optional string blueprint_name = 2;
}

message ListClustersResponse {
  repeated ListClustersUnitResponse clusters = 1;
}

message ListPartitionsRequest {
  string name = 1; // Accepts cluster name as input
}

message ListPartitionsUnitResponse {
  string name = 1; // Partition name
}

message ListPartitionsResponse {
  repeated ListPartitionsUnitResponse partitions = 1; // List of partition names
}

message ListAccountsRequest {
  string name = 1; // Accepts cluster name as input
}

message ListAccountsUnitResponse {
  string name = 1; // Account name
}

message ListAccountsResponse {
  repeated ListAccountsUnitResponse accounts = 1; // List of account names
}

message DeleteClusterRequest {
  string name = 1;
  bool force = 2; // allow deleting cluster even if it has running jobs
}

message DeleteClusterResponse {
  bool deleted = 1;
}

message SetClusterInit {
  string name = 1;
  optional string host = 2;
  optional string username = 3;
  optional uint32 port = 4;
  optional string identity_path = 5;
  optional string default_base_path = 6;
  optional bool is_default = 7;
}

message SetClusterRequest {
  oneof msg {
    SetClusterInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message ReconnectClusterInit {
  string name = 1;
}

message ReconnectClusterRequest {
  oneof msg {
    ReconnectClusterInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message ReconnectClusterDone {}

message ReconnectClusterStreamEvent {
  oneof event {
    MfaPrompt mfa = 1;
    ReconnectClusterDone done = 2;
  }
}

message ListJobsUnitResponse {
  string name = 1;
  int64 job_id = 2;
  optional int64 scheduler_id = 3;
  string created_at = 4;
  optional string finished_at = 5;
  bool is_completed = 6;
  optional string terminal_state = 7; // Scheduler terminal state when known (COMPLETED, FAILED)
  string local_path = 8; // Local directory used for submission
  string remote_path = 9; // Remote directory used for submission
  optional string scheduler_state = 10; // Scheduler state when known (PENDING, RUNNING)
  optional string blueprint_name = 11; // blueprint identifier from Orbitfile at run time
  optional string default_retrieve_path = 12; // default retrieve path stored at run time
}

message ListJobsResponse {
  repeated ListJobsUnitResponse jobs = 1;
}

message BlueprintRecord {
  string name = 1;
  reserved 2;
  string created_at = 3;
  string updated_at = 4;
  optional string version_tag = 5;
  optional string tarball_hash = 6;
  optional string tool_version = 7;
  optional string template_config_json = 8;
  reserved 9;
  optional string submit_sbatch_script = 10;
  repeated string sbatch_scripts = 11;
  optional string default_retrieve_path = 12;
  repeated string sync_include = 13;
  repeated string sync_exclude = 14;
  optional string tarball_hash_function = 15;
}

message BuildBlueprintRequest {
  string path = 1; // blueprint root to package
  bool package_git = 2; // include .git in tarball
  reserved 3;
}

message BuildBlueprintResponse {
  BlueprintRecord blueprint = 1;
}

message UpsertBlueprintRequest {
  string name = 1;
  reserved 2;
}

message UpsertBlueprintResponse {
  BlueprintRecord blueprint = 1;
}

message GetBlueprintRequest {
  string name = 1;
}

message GetBlueprintResponse {
  BlueprintRecord blueprint = 1;
}

message ListBlueprintsRequest {}

message ListBlueprintsResponse {
  repeated BlueprintRecord blueprints = 1;
}

message DeleteBlueprintRequest {
  string name = 1;
}

message DeleteBlueprintResponse {
  bool deleted = 1;
}

// Client -> Server
message RunJobRequest {
  oneof msg {
    RunJobRequestInit init = 1; // Initial file path submission
    MfaAnswer mfa = 2;
  }
}

// Client -> Server
message RunBlueprintRequest {
  oneof msg {
    RunBlueprintRequestInit init = 1; // Initial blueprint submission
    MfaAnswer mfa = 2;
  }
}
message AddClusterRequest {
  oneof msg {
    AddClusterInit init = 1;
    MfaAnswer mfa = 2;
    AddClusterScratchSelection scratch_selection = 3;
    AddClusterBasePathSelection base_path_selection = 4;
    AddClusterDefaultSelection default_selection = 5; // final default choice, sent at the end
  }
}

message PingRequest {
  string message = 1;
}

message PingReply {
  string message = 1;
}

// One bidirectional streaming method keeps MFA + output on a single pipe.
service Agent {
  rpc Ping(PingRequest) returns (PingReply);
  rpc Ls(stream LsRequest) returns (stream StreamEvent);
  rpc RetrieveJob(stream RetrieveJobRequest) returns (stream StreamEvent);
  rpc JobLogs(stream JobLogsRequest) returns (stream StreamEvent);
  rpc CancelJob(stream CancelJobRequest) returns (stream StreamEvent);
  rpc CleanupJob(stream CleanupJobRequest) returns (stream StreamEvent);
  rpc RunJob(stream RunJobRequest) returns (stream RunStreamEvent);
  rpc RunBlueprint(stream RunBlueprintRequest) returns (stream RunStreamEvent);
  rpc AddCluster(stream AddClusterRequest) returns (stream StreamEvent);
  rpc ResolveHomeDir(stream ResolveHomeDirRequest) returns (stream StreamEvent);
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse);
  rpc ListPartitions(ListPartitionsRequest) returns (ListPartitionsResponse); // Helper endpoint for listing partitions
  rpc ListAccounts(ListAccountsRequest) returns (ListAccountsResponse); // Helper endpoint for listing accounts
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse);
  rpc SetCluster(stream SetClusterRequest) returns (stream StreamEvent);
  rpc ReconnectCluster(stream ReconnectClusterRequest) returns (stream ReconnectClusterStreamEvent);
  rpc ListJobs(ListJobsRequest) returns (ListJobsResponse);
  rpc UpsertBlueprint(UpsertBlueprintRequest) returns (UpsertBlueprintResponse);
  rpc GetBlueprint(GetBlueprintRequest) returns (GetBlueprintResponse);
  rpc ListBlueprints(ListBlueprintsRequest) returns (ListBlueprintsResponse);
  rpc DeleteBlueprint(DeleteBlueprintRequest) returns (DeleteBlueprintResponse);
  rpc BuildBlueprint(BuildBlueprintRequest) returns (BuildBlueprintResponse);
}
