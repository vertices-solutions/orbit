syntax = "proto3";
package  agent.v1;

// A single prompt displayed during keyboard-interactive auth (e.g. "Duo code:").
message Prompt {
  string text = 1;
  bool echo = 2; // Whether the server allows echoing the user's input
}

// MFA prompt bundle (a single "round" of keyboard-interactive).
message MfaPrompt {
  string name = 1;          // e.g. "Duo Security"
  string instructions = 2;  // Free text instructions
  repeated Prompt prompts = 3;
}

// Client's answers to a single MFA prompt round.
// The number of responses must match the number of `prompts`.
message MfaAnswer {
  repeated string responses = 1;
}

// Server->client stream items while running a command.
message StreamEvent {
  oneof event {
    bytes stdout = 1;        // Chunk from STDOUT
    bytes stderr = 2;        // Chunk from STDERR
    int32 exit_code = 3;     // Exit code (emitted once when known)
    MfaPrompt mfa = 4;       // MFA prompt round
    string error = 5;        // Fatal error (connection/auth/exec)
  }
}

message SubmitStatus {
  enum Phase {
    PHASE_UNSPECIFIED = 0;
    RESOLVED = 1;
    TRANSFER_START = 2;
    TRANSFER_DONE = 3;
  }
  string hostid = 1;
  string remote_path = 2;
  Phase phase = 3;
}

message SubmitResult {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    SUBMITTED = 1;
    FAILED = 2;
  }
  Status status = 1;
  optional int64 job_id = 2;
  string detail = 3;
}

// Server->client stream items while submitting a job.
message SubmitStreamEvent {
  oneof event {
    bytes stdout = 1;        // Chunk from STDOUT
    bytes stderr = 2;        // Chunk from STDERR
    int32 exit_code = 3;     // Exit code (emitted once when known)
    MfaPrompt mfa = 4;       // MFA prompt round
    string error = 5;        // Fatal error (connection/auth/exec)
    SubmitStatus submit_status = 6; // Submit progress updates
    SubmitResult submit_result = 7; // Submit final status
  }
}

message LsRequestInit {
  string hostid = 1;       // host identifier
  optional string path = 2; // path to list (absolute or relative to default_base_path)
}

// Client -> Server
message LsRequest {
  oneof msg {
    LsRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message RetrieveJobRequestInit {
  int64 job_id = 1; // internal job id from the daemon
  optional string hostid = 2; // optional host identifier to validate ownership
  string path = 3;         // remote path (absolute or relative to run folder)
  optional string local_path = 4; // local destination base path
}

message RetrieveJobRequest {
  oneof msg {
    RetrieveJobRequestInit init = 1;
    MfaAnswer mfa = 2;
  }
}






message SubmitRequestInit {
  string local_path = 1;  // local project path
  optional string remote_path = 2; // path to where to locate the remote project
  string hostid = 3;      // host identifier - should be something easy to remember
  string sbatchscript = 4;
  repeated SubmitPathFilterRule filters = 5; // ordered include/exclude rules, rsync-style
}

enum SubmitPathFilterAction {
  SUBMIT_PATH_FILTER_ACTION_UNSPECIFIED = 0;
  INCLUDE = 1;
  EXCLUDE = 2;
}

message SubmitPathFilterRule {
  SubmitPathFilterAction action = 1;
  string pattern = 2;
}

message AddClusterInit {
  string hostid = 1;  // memorable host identifier
  string username = 2; // path to where to locate the remote project
  oneof host {
    string hostname = 3;      // host identifier - should be something easy to remember
    string ipaddr = 4;
  }
  optional string identity_path = 5;
  uint32 port = 6;
  optional string default_base_path = 7;
}
message ListClustersRequest {
  string filter = 1;
}

message ListClustersUnitResponse {
  string username = 1;
  optional string identity_path = 2;
  int32 port = 3;
  oneof host {
    string hostname = 4;
    string ipaddr = 5;
  }
  bool connected = 6;
  string hostid = 7;
  bool accounting_available = 8;
  optional string default_base_path = 9;
}




message ListJobsRequest {
  optional string hostid = 1;
}

message ListClustersResponse {
  repeated ListClustersUnitResponse clusters = 1;
}



message ListJobsUnitResponse {
  string hostid = 1;
  int64 job_id = 2;
  optional int64 slurm_id = 3;
  string created_at = 4;
  optional string finished_at = 5;
  bool is_completed = 6;
  optional string terminal_state = 7; // SLURM terminal state when known (e.g., COMPLETED, FAILED)
}

message ListJobsResponse {
  repeated ListJobsUnitResponse jobs = 1;
}


// Client -> Server
message SubmitRequest {
  oneof msg {
    SubmitRequestInit init = 1; // Initial file path submission
    MfaAnswer mfa = 2;
  }
}
message AddClusterRequest {
  oneof msg {
    AddClusterInit init = 1;
    MfaAnswer mfa = 2;
  }
}

message PingRequest { string message = 1; }


message PingReply { string message = 1; }
// One bidirectional streaming method keeps MFA + output on a single pipe.
service Agent {
  rpc Ping(PingRequest) returns (PingReply);
  rpc Ls(stream LsRequest) returns (stream StreamEvent);
  rpc RetrieveJob(stream RetrieveJobRequest) returns (stream StreamEvent);
  rpc Submit(stream SubmitRequest) returns (stream SubmitStreamEvent);
  rpc AddCluster(stream AddClusterRequest) returns (stream StreamEvent);
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse);
  rpc ListJobs(ListJobsRequest) returns (ListJobsResponse);
}
